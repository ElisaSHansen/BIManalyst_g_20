"""
A3_IFC4x3_Compatible.py
Fully IFC 4x3–compliant script for column capacity extraction and checking.
Requires: ifcopenshell (with OCC support)
"""

import ifcopenshell as ifc
from collections import defaultdict, Counter
from contextlib import redirect_stdout
import math
import re

# --- Input parameters ---
fc = 35 # N/mm² – compressive strength of concrete
gamma_m0 = 1.45  # material safety factor
Ned = 882.78  # axial design load (kN)
TOL = 0.002  # 2 mm tolerance for base elevation

# --- Open IFC model ---
model = ifc.open("25-16-D-STR.ifc")

# --- Geometry settings ---
try:
    import ifcopenshell.geom as geom
    settings = geom.settings()
    try:
        settings.set(settings.USE_WORLD_COORDS, True)
    except Exception:
        pass
except Exception as e:
    print("❌ ifcopenshell.geom not available – OCC kernel required.", e)
    raise SystemExit(1)

# ---------------------------------------------------------------
# IFC 4x3–compliant helper functions
# ---------------------------------------------------------------

def get_material_from_ifc(element):
    """Return associated IfcMaterial name (or layer list) if available."""
    for rel in model.get_inverse(element):
        if rel.is_a("IfcRelAssociatesMaterial"):
            mat = rel.RelatingMaterial
            if mat.is_a("IfcMaterial"):
                return mat.Name
            elif mat.is_a("IfcMaterialLayerSet"):
                return ", ".join(
                    layer.Material.Name for layer in mat.MaterialLayers if layer.Material
                )
            elif mat.is_a("IfcMaterialList"):
                return ", ".join(m.Name for m in mat.Materials if m)
    return None


def get_profile_from_ifc(element):
    """Return section dimensions from IfcProfileDef, e.g. '0.3x0.3 m' or 'Ø0.4 m'."""
    rep = getattr(element, "Representation", None)
    if not rep:
        return None
    try:
        for rep_ctx in rep.Representations:
            for item in rep_ctx.Items:
                if item.is_a("IfcExtrudedAreaSolid"):
                    prof = item.SweptArea
                    if prof.is_a("IfcRectangleProfileDef"):
                        return f"{prof.XDim:.3f}x{prof.YDim:.3f} m"
                    elif prof.is_a("IfcCircleProfileDef"):
                        return f"Ø{prof.Radius * 2:.3f} m"
    except Exception:
        pass
    return None


def area_from_ifc_profile(element):
    """Return section area in m² from profile definition."""
    rep = getattr(element, "Representation", None)
    if not rep:
        return None
    try:
        for rep_ctx in rep.Representations:
            for item in rep_ctx.Items:
                if item.is_a("IfcExtrudedAreaSolid"):
                    prof = item.SweptArea
                    if prof.is_a("IfcRectangleProfileDef"):
                        return float(prof.XDim) * float(prof.YDim)
                    elif prof.is_a("IfcCircleProfileDef"):
                        r = float(prof.Radius)
                        return math.pi * r * r
    except Exception:
        pass
    return None


def get_bbox_minmax_z(element):
    """Return (min_z, max_z) of column geometry in meters."""
    try:
        shape = geom.create_shape(settings, element)
        verts = shape.geometry.verts  # flat [x, y, z, ...]
        zs = verts[2::3]
        if not zs:
            return None
        return min(zs), max(zs)
    except Exception:
        return None


# ---------------------------------------------------------------
# Collect data from all columns
# ---------------------------------------------------------------

columns_data = []

for col in model.by_type("IfcColumn"):
    gid = col.GlobalId
    name = getattr(col, "Name", "") or "(no name)"
    mat = get_material_from_ifc(col) or "Unknown"
    prof = get_profile_from_ifc(col) or "Unknown"
    area = area_from_ifc_profile(col)
    mm = get_bbox_minmax_z(col)

    if not mm or not area:
        continue

    zmin, zmax = mm
    height = zmax - zmin

    # base check (Z≈0)
    if not (-TOL <= zmin <= TOL):
        continue

    columns_data.append(
        dict(
            GlobalId=gid,
            Name=name,
            Material=mat,
            Profile=prof,
            Area_m2=area,
            Height_m=height,
        )
    )

# ---------------------------------------------------------------
# Compute and print results
# ---------------------------------------------------------------

print("\n=== IFC 4x3 Column Capacity Report ===\n")

summary = defaultdict(list)

for c in columns_data:
    A_mm2 = c["Area_m2"] * 1e6
    Nrd = (fc * A_mm2 / gamma_m0) / 1000  # [kN]
    util = round((Ned / Nrd) * 100, 2)
    ok = "OK ✅" if Nrd >= Ned else "⚠️  Possibly insufficient"
    summary[c["Material"]].append((c["Profile"], Nrd, util, ok))

    print(f"GlobalId: {c['GlobalId']}")
    print(f"  Material: {c['Material']}")
    print(f"  Profile: {c['Profile']}")
    print(f"  Height: {c['Height_m']:.3f} m")
    print(f"  Area: {A_mm2:.0f} mm²")
    print(f"  Nrd = {round(Nrd,1)} kN | Ned = {Ned} kN | Utilization = {util}% → {ok}")
    print("")

# ---------------------------------------------------------------
# Save report to file
# ---------------------------------------------------------------

with open("Capacity.control.report.txt", "w", encoding="utf-8") as f, redirect_stdout(f):
    print("=== IFC 4x3 Column Capacity Report ===\n")
    for c in columns_data:
        A_mm2 = c["Area_m2"] * 1e6
        Nrd = (fc * A_mm2 / gamma_m0) / 1000
        util = round((Ned / Nrd) * 100, 2)
        ok = "OK" if Nrd >= Ned else "NOT OK"
        print(f"{c['GlobalId']}, {c['Material']}, {c['Profile']}, "
              f"A={A_mm2:.0f} mm², Nrd={round(Nrd,1)} kN, "
              f"Util={util}%, {ok}")
    print("\nReport generated successfully.")